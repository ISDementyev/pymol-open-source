import argparse
import glob
import os
import pathlib
import re
import sys
import sysconfig
import shutil
import urllib.request as urllib2

from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext
from setuptools.command.build_py import build_py
from setuptools.command.install import install

import create_shadertext

DEBUG = bool(os.getenv('DEBUG', ''))

WIN = sys.platform.startswith('win')
MAC = sys.platform.startswith('darwin')

if MAC:
    OS_CPU = OS_CPU_EXT = 'Darwin-x86_64'
elif not WIN:
    OS_CPU = OS_CPU_EXT = 'Linux-x86_64'
elif '64 bit' in sys.version:
    OS_CPU = "Windows-x64"
    OS_CPU_EXT = "Win64"
else:
    OS_CPU = "WIN32-x86"
    OS_CPU_EXT = "Win32"

# True if conda is just parsing for package data
CONDA_LOAD_DATA = not setup.__module__.startswith('setuptools')


# handle extra arguments
class options:
    osx_frameworks = True
    jobs = int(os.getenv('JOBS', 0))
    no_mmlibs = True
    no_libxml = False
    pyqt = 'PyQt5,PyQt4,PySide'
    no_glut = True
    use_msgpackc = 'c++11'
    help_distutils = False
    no_licensing = CONDA_LOAD_DATA
    testing = False
    openvr = False
    use_openmp = 'no' if MAC else 'yes'
    use_vtkm = '1.5'
    vmd_plugins = True
    lookingglass = True


parser = argparse.ArgumentParser()
parser.add_argument('--no-licensing', action="store_true")
parser.add_argument('--mmlibs',
                    dest='no_mmlibs',
                    action="store_false",
                    help="link with mmpymolx (stereo labeling, mtz import)")
parser.add_argument('--pyqt')
parser.add_argument('--glut',
                    dest='no_glut',
                    action="store_false",
                    help="link with GLUT (legacy GUI)")
parser.add_argument('--no-osx-frameworks',
                    dest='osx_frameworks',
                    help="on MacOS use XQuartz instead of native frameworks",
                    action="store_false")
parser.add_argument('--jobs',
                    '-j',
                    type=int,
                    help="for parallel builds "
                    "(defaults to number of processors)")
parser.add_argument('--no-libxml',
                    action="store_true",
                    help="skip libxml2 dependency, disables COLLADA export")
parser.add_argument('--use-openmp', choices=('yes', 'no'), help="Use OpenMP")
parser.add_argument('--use-vtkm',
                    choices=('1.5', '1.6', '1.7', 'no'),
                    help="Use VTK-m for isosurface generation")
parser.add_argument(
    '--use-msgpackc',
    choices=('c++11', 'c', 'guess', 'no'),
    help="c++11: use msgpack-c header-only library; c: link against "
    "shared library; no: disable fast MMTF load support")
parser.add_argument('--help-distutils',
                    action="store_true",
                    help="show help for distutils options and exit")
parser.add_argument('--testing',
                    action="store_true",
                    help="Build C-level tests")
parser.add_argument('--openvr', dest='openvr', action='store_true')
parser.add_argument('--no-vmd-plugins',
                    dest='vmd_plugins',
                    action='store_false',
                    help='Disable VMD molfile plugins (libnetcdf dependency)')
parser.add_argument('--no-lookingglass',
                    dest='lookingglass',
                    action="store_false")
options, sys.argv[1:] = parser.parse_known_args(namespace=options)

if options.help_distutils:
    sys.argv.append("--help")

if not CONDA_LOAD_DATA or sys.platform.startswith('win'):
    # on Windows import even during CONDA_LOAD_DATA to fix VS120COMNTOOLS
    import monkeypatch_distutils
    monkeypatch_distutils.set_parallel_jobs(options.jobs)


def forms_uic(build_lib='modules'):
    '''
    Convert Qt UI files in "modules/pmg_qt/forms" to Python files in place
    '''
    if options.pyqt == 'no':
        return

    for name in options.pyqt.split(','):
        uicname = 'pysideuic' if (name == 'PySide') else (name + '.uic')
        try:
            __import__(uicname)
        except ImportError:
            print(f"Notice: Cannot import {uicname}")
            continue
        break
    else:
        raise ImportError(f'cannot import uic for --pyqt={options.pyqt}')

    print("Notice: Using " + name)

    def build_lib_map(sourcedir, filename):
        d = build_lib + sourcedir[7:]  # replace "modules"
        return (d, filename)

    compileUiDir = sys.modules[uicname].compileUiDir
    compileUiDir(os.path.join('modules', 'pmg_qt', 'forms'), map=build_lib_map)

    # write file which hard codes the used Qt Python lib
    with open(os.path.join(build_lib, 'pymol', '_Qt_pre.py'), 'w') as handle:
        handle.write('# generated by setup.py\n')
        if name == 'PyQt4':
            handle.write('__import__("sip").setapi("QString", 2)\n')
        handle.write('from ' + name + ' import QtGui, QtCore, QtOpenGL\n')
        handle.write('PYQT_NAME = "' + name + '"')


def get_prefix_path():
    '''
    Return a list of paths which will be searched for "include",
    "include/freetype2", "lib", "lib64" etc.
    '''
    try:
        return os.environ['PREFIX_PATH'].split(os.pathsep)
    except KeyError:
        pass

    if sys.platform.startswith("freebsd"):
        return ["/usr/local"]

    X11 = ['/usr/X11'] * (not options.osx_frameworks)

    if sys.platform == 'darwin':
        for prefix in ['/sw', '/opt/local', '/usr/local']:
            if sys.base_prefix.startswith(prefix):
                return [prefix] + X11

    if is_conda_env():
        if sys.platform.startswith('win'):
            return [os.path.join(sys.prefix, 'Library')]

        return [sys.prefix] + X11

    return ['/usr'] + X11


def is_conda_env():
    return ('conda' in sys.prefix or 'conda' in sys.version
            or 'Continuum' in sys.version
            or sys.prefix == os.getenv('CONDA_PREFIX'))


def guess_msgpackc():
    for prefix in prefix_path:
        f = os.path.join(prefix, 'include', 'msgpack', 'version_master.h')

        try:
            m = re.search(r'MSGPACK_VERSION_MAJOR\s+(\d+)', open(f).read())
        except EnvironmentError:
            continue

        if m is not None:
            major = int(m.group(1))
            if major > 1:
                return 'c++11'

    return 'no'


class WinLibFinder:
    searchpath = [
        os.getenv('PREFIX', sys.prefix),
    ]

    @classmethod
    def _generate(cls, libpath):
        for p in cls.searchpath:
            yield os.path.join(p, libpath)

    @classmethod
    def find(cls, libpath):
        for path in cls._generate(libpath):
            if os.path.exists(path):
                return path
        raise LookupError('not found: ' + libpath)

    @classmethod
    def get_glut32pymol_libs(cls):
        if options.no_glut:
            return []
        return [cls.find(r"glut-3.7.6\lib\glut32pymol.lib")]

    @classmethod
    def get_schrodinger_libs(cls):
        windows_libs = [
            cls.find(r"glew-1.5.6\lib\glew32.lib"),
            cls.find(r"libpng-1.6.2\lib\libpng16.lib"),
            cls.find(r"zlib-1.2.8\lib\zlib.lib"),
            cls.find(r"freetype-2.3.5\lib\libfreetype.lib"),
        ]

        if not options.no_libxml:
            windows_libs += [
                cls.find(r"libxml2-2.9.4\lib\libxml2.lib"),
                cls.find(r"iconv-1.14\lib\iconv.lib"),
            ]

        return windows_libs + cls.get_glut32pymol_libs()


class CMakeExtension(Extension):
    def __init__(self, name):
        # don't invoke the original build_ext for this special extension
        super().__init__(name, sources=[])


class build_ext_pymol(build_ext):
    def run(self):
        for ext in self.extensions:
            self.build_cmake(ext)
        super().run()

    def build_cmake(self, ext):
        cwd = pathlib.Path().absolute()

        # these dirs will be created in build_py, so if you don't have
        # any python sources to bundle, the dirs will be missing
        build_temp = pathlib.Path(self.build_temp)
        print(f"BUILDTMP {build_temp}")
        build_temp.mkdir(parents=True, exist_ok=True)
        extdir = pathlib.Path(self.get_ext_fullpath(ext.name))
        extdir.mkdir(parents=True, exist_ok=True)

        def concat_paths(paths):
            return ''.join(path.replace('\\', '/') + ";" for path in paths)

        py_lib = pathlib.Path(sysconfig.get_paths()['stdlib']).parent / 'libs'
        lib_dirs.append(str(py_lib))

        config = 'Debug' if DEBUG else 'Release'
        lib_output_dir = str(extdir.parent.absolute())
        print(f"LIB OUTPUT DIR: {lib_output_dir}")
        all_files = get_sources(pymol_src_dirs)
        all_src = concat_paths(all_files)
        all_defs = ''.join(mac[0] + ";" for mac in def_macros)
        all_libs = ''.join(f"{lib};" for lib in libs)
        all_lib_dirs = concat_paths(lib_dirs)
        all_inc_dirs = concat_paths(inc_dirs)
        all_ext_objs = concat_paths(ext_objects)

        lib_mode = "RUNTIME" if WIN else "LIBRARY"

        cmake_args = [
            f"-DCMAKE_{lib_mode}_OUTPUT_DIRECTORY={lib_output_dir}",
            f"-DCMAKE_BUILD_TYPE={config}",
            f"-DALL_INC_DIR={all_inc_dirs}",
            f"-DALL_SRC={all_src}",
            f"-DALL_DEF={all_defs}",
            f"-DALL_LIB_DIR={all_lib_dirs}",
            f"-DALL_LIB={all_libs}",
            f"-DALL_EXT_OBJ={all_ext_objs}",
        ]

        # example of build args
        build_args = ['--config', config]
        if not WIN:  # Win /MP flag on compilation level
            build_args += ['-j8']

        os.chdir(str(build_temp))
        self.spawn(['cmake', str(cwd)] + cmake_args)
        if not self.dry_run:
            self.spawn(['cmake', '--build', '.'] + build_args)
        # Troubleshooting: if fail on line above then delete all possible
        # temporary CMake files including "CMakeCache.txt" in top level dir.
        os.chdir(str(cwd))


class build_py_pymol(build_py):
    def run(self):
        build_py.run(self)
        forms_uic(self.build_lib)


class install_pymol(install):
    pymol_path = None
    no_launcher = False

    user_options = install.user_options + [
        ('pymol-path=', None, 'PYMOL_PATH'),
        ('bundled-pmw', None, 'install bundled Pmw module'),
        ('no-launcher', None, 'skip installation of the pymol launcher'),
    ]

    def finalize_options(self):
        super().finalize_options()
        if self.pymol_path is None:
            self.pymol_path = os.path.join(self.install_libbase, 'pymol',
                                           'pymol_path')
        elif self.root is not None:
            self.pymol_path = install_pymol.change_root(
                self.root, self.pymol_path)

    @staticmethod
    def change_root(new_root, pathname):
        """
        Return 'pathname' with 'new_root' prepended.  If 'pathname' is
        relative, this is equivalent to "os.path.join(new_root,pathname)".
        Otherwise, it requires making 'pathname' relative and then joining the
        two, which is tricky on DOS/Windows and Mac OS.
        """
        if os.name == 'posix':
            if not os.path.isabs(pathname):
                return os.path.join(new_root, pathname)
            else:
                return os.path.join(new_root, pathname[1:])

        elif os.name == 'nt':
            (drive, path) = os.path.splitdrive(pathname)
            if path[0] == '\\':
                path = path[1:]
            return os.path.join(new_root, path)

    def run(self):
        super().run()
        self.install_pymol_path()
        self.install_dlls()
        self.install_pymol_lib()

        if not self.no_launcher:
            self.make_launch_script()

        if sys.platform.startswith('darwin'):
            self.make_macos_app()

    def unchroot(self, name):
        if self.root is not None and name.startswith(self.root):
            return name[len(self.root):]
        return name

    def copy_tree_nosvn(self, src, dst):
        def ignore(src, names):
            return set([]).intersection(names)

        if os.path.exists(dst):
            shutil.rmtree(dst)
        print(f"copying {src} -> {dst}")
        shutil.copytree(src, dst, ignore=ignore)

    def copy(self, src, dst):
        copy = self.copy_tree_nosvn if os.path.isdir(src) else self.copy_file
        copy(src, dst)

    def install_pymol_path(self):
        self.mkpath(self.pymol_path)
        for name in [
                'data',
                'examples',
        ]:
            self.copy(name, os.path.join(self.pymol_path, name))
        # generated smaa shader files

        shaders_dir = os.path.join(self.pymol_path, 'data', 'shaders')
        print(f"shaders dir {shaders_dir}")
        shaders_gen = glob.glob(os.path.join(generated_dir, 'smaa_gen.*'))
        print(f"MYL: {shaders_gen}")
        for name in glob.glob(os.path.join(generated_dir, 'smaa_gen.*')):
            self.copy(name, shaders_dir)

    def install_dlls(self):
        # windows dlls
        dll_dir = os.path.join(self.install_libbase, 'pymol')
        self.mkpath(dll_dir)
        for lib in windows_libs:
            print(f"DLL {lib}")
            dll = lib[:-3] + 'dll'
            A, B = os.path.split(dll)
            if not os.path.exists(dll):
                # not in same directory, but in "bin" (e.g. our glew32.dll)
                dll = os.path.join(os.path.split(A)[0], 'bin', B)
            if os.path.exists(dll):
                self.copy(dll, os.path.join(dll_dir, B))

        if options.openvr:
            self.copy('contrib/vr/README.md',
                      os.path.join(self.pymol_path, 'README-VR.txt'))

    def install_pymol_lib(self):
        lib_path = pathlib.Path(self.build_lib) / "pymol"
        if WIN:
            lib_path = lib_path / "Release" / "_cmd.pyd"
        else:
            lib_path = lib_path / "_cmd.so"

        dst = pathlib.Path(self.pymol_path).parent
        self.copy(str(lib_path), str(dst))

    def make_launch_script(self):
        if sys.platform.startswith('win'):
            launch_script = 'pymol.bat'
        else:
            launch_script = 'pymol'

        self.mkpath(self.install_scripts)
        launch_script = os.path.join(self.install_scripts, launch_script)

        python_exe = os.path.abspath(sys.executable)
        pymol_file = self.unchroot(
            os.path.join(self.install_libbase, 'pymol', '__init__.py'))
        pymol_path = self.unchroot(self.pymol_path)

        with open(launch_script, 'w') as out:
            if sys.platform.startswith('win'):
                # paths relative to launcher, if possible
                try:
                    python_exe = '%~dp0\\' + os.path.relpath(
                        python_exe, self.install_scripts)
                except ValueError:
                    pass
                try:
                    pymol_file = '%~dp0\\' + os.path.relpath(
                        pymol_file, self.install_scripts)
                except ValueError:
                    pymol_file = os.path.abspath(pymol_file)

                # out.write('set PYMOL_PATH=' + pymol_path + os.linesep)
                out.write('"%s" "%s"' % (python_exe, pymol_file))
                out.write(' %*' + os.linesep)
            else:
                out.write('#!/bin/sh' + os.linesep)
                out.write('export PYMOL_PATH="%s"' % pymol_path + os.linesep)
                out.write('exec "%s" "%s" "$@"' % (python_exe, pymol_file) +
                          os.linesep)

        os.chmod(launch_script, 0o755)

    def make_macos_app(self):
        '''
        Create $PREFIX/PyMOL.app

        Intended for Anaconda, so this would typically create
        /opt/anaconda/PyMOL.app

        '''
        prefix = os.getenv('PREFIX')
        if not prefix:
            return

        bundlename = 'PyMOL'
        version = get_pymol_version()
        contents_dir = os.path.join(prefix, bundlename + '.app', 'Contents')

        # MacOS
        macos_dir = os.path.join(contents_dir, 'MacOS')
        self.mkpath(macos_dir)
        launch_script = os.path.join(macos_dir, bundlename)
        with open(launch_script, 'w') as out:
            out.write('#!/bin/bash\n'
                      'export PYTHONEXECUTABLE=' + sys.executable + '\n' +
                      macos_dir + '/python -m pymol -J\n')
        os.chmod(launch_script, 0o755)

        # python in MacOS
        os.symlink(os.path.relpath(sys.executable, macos_dir),
                   os.path.join(macos_dir, 'python'))

        # Resources
        resources_dir = os.path.join(contents_dir, 'Resources')
        self.mkpath(resources_dir)
        self.copy('incentive_pymol/MacPyMOL/MacPyMOL/PDB.icns', resources_dir)
        self.copy('icons/icon2.icns', resources_dir + '/pymol.icns')

        # Info.plist
        import plistlib
        with open('incentive_pymol/MacPyMOL/MacPyMOL/Info.plist', 'rb') as fp:
            info = plistlib.load(fp)
        info['CFBundleShortVersionString'] = version
        # can only contain numeric characters (0-9) and periods
        version = re.sub(r'[^.0-9].*', '', version)
        info['CFBundleVersion'] = version
        with open(os.path.join(contents_dir, 'Info.plist'), 'wb') as fp:
            plistlib.dump(info, fp)


# should be something like (build_base + "/generated"), but that's only
# known to build and install instances
generated_dir = os.path.join(os.environ.get("PYMOL_BLD", "build"), "generated")

incentive_dir = "incentive_pymol"

create_shadertext.create_all(generated_dir)

# can be changed with environment variable PREFIX_PATH
prefix_path = get_prefix_path()

inc_dirs = [
    "include",
    sysconfig.get_paths()['include'],
]

pymol_src_dirs = [
    "ov/src",
    "layer0",
    "layer1",
    "layer2",
    "layer3",
    "layer4",
    "layer5",
    generated_dir,

    # incentive
    os.path.join(incentive_dir, "epymol", "src"),
]

def_macros = [
    ("_PYMOL_LIBPNG", None),
    ("_PYMOL_FREETYPE", None),

    # incentive
    ("PYMOL_COMM", None),
    ("_PYMOL_INCENTIVE", None),
]

if DEBUG and not WIN:
    def_macros += [
        # bounds checking in STL containers
        ("_GLIBCXX_ASSERTIONS", None),
    ]

libs = ["png", "freetype"]

lib_dirs = [
    sysconfig.get_paths()['stdlib']
]

ext_comp_args = [
    "-Werror=return-type",
    "-Wunused-variable",
    "-Wno-switch",
    "-Wno-narrowing",
    # legacy stuff
    '-Wno-char-subscripts',
    # optimizations
    "-Og" if DEBUG else "-O3",
] if not WIN else []
ext_link_args = []
ext_objects = []
data_files = []
ext_modules = []
windows_libs = []

if options.use_openmp == 'yes':
    def_macros += [
        ("PYMOL_OPENMP", None),
    ]
    if MAC:
        ext_comp_args += ["-Xpreprocessor", "-fopenmp"]
        libs += ["omp"]
    elif WIN:
        ext_comp_args += ["/openmp"]
    else:
        ext_comp_args += ["-fopenmp"]
        ext_link_args += ["-fopenmp"]

if options.vmd_plugins:
    # VMD plugin support
    inc_dirs += [
        'contrib/uiuc/plugins/include',
    ]
    pymol_src_dirs += [
        'contrib/uiuc/plugins/molfile_plugin/src',
    ]
    def_macros += [
        ("_PYMOL_VMD_PLUGINS", None),
    ]

if not options.no_libxml:
    # COLLADA support
    def_macros += [("_HAVE_LIBXML", None)]
    libs += ["xml2"]

if options.use_msgpackc == 'guess':
    options.use_msgpackc = guess_msgpackc()

if options.use_msgpackc == 'no':
    def_macros += [("_PYMOL_NO_MSGPACKC", None)]
else:
    if options.use_msgpackc == 'c++11':
        def_macros += [("MMTF_MSGPACK_USE_CPP11", None)]
    else:
        libs += ['msgpackc']

    pymol_src_dirs += ["contrib/mmtf-c"]

if options.no_glut:
    def_macros += [
        ("_PYMOL_NO_MAIN", None),
    ]

if options.testing:
    pymol_src_dirs += ["layerCTest"]
    def_macros += [("_PYMOL_CTEST", None)]

if options.openvr:
    def_macros += [("_PYMOL_OPENVR", None)]
    pymol_src_dirs += [
        "contrib/vr",
    ]

inc_dirs += pymol_src_dirs

#============================================================================
if MAC:
    def_macros += [("PYMOL_CURVE_VALIDATE", None)]
    # 3DconnexionClient
    for F in [
            sys.prefix + '/Frameworks',
    ]:
        if os.path.exists(F + '/3DconnexionClient.framework'):
            ext_comp_args += ["-F" + F]
            ext_link_args += [
                "-F" + F,
                "-weak_framework",
                "3DconnexionClient",
            ]
            break
    else:
        def_macros += [("_PYMOL_NO_3DCONNEXIONCLIENT", None)]

    # mmpymolx
    if not options.no_mmlibs:
        libs += [
            "mkl_core", "mkl_intel_ilp64", "mkl_lapack95_ilp64",
            "mkl_sequential", "json_clang_libmt"
        ]

    libs += ["GLEW"]

    if options.osx_frameworks:
        ext_link_args += [
            "-framework",
            "OpenGL",
        ] + (not options.no_glut) * [
            "-framework",
            "GLUT",
        ]
        def_macros += [
            ("_PYMOL_OSX", None),
        ]
    else:
        libs += [
            "GL",
        ] + (not options.no_glut) * [
            "glut",
        ]

if WIN:
    # Visual Studio Express requires the following fix:
    # +++ C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/vcvarsall.bat
    # -if /i %1 == amd64     goto amd64
    # +if /i %1 == amd64     goto x86_amd64
    # Note: "error: Unable to find vcvarsall.bat" may occur if compiler is not installed
    # with Visual Studio

    # clear
    libs = []

    def_macros += [
        ("WIN32", None),
        ("_CONSOLE", None),
        ("_UNICODE", None),
        ("UNICODE", None),
    ]

    libs += [
        "User32",  # Clipboard (OpenClipboard etc.)
        "Advapi32",  # Registry (RegCloseKey etc.)
        "Ws2_32",  # htonl
    ]

    if 'conda' in sys.executable.lower():
        # dependencies from conda environment

        libs += [
            "glew32",
            "freetype",
            "libpng",
        ] + (not options.no_glut) * [
            "freeglut",
        ] + (not options.no_libxml) * [
            "libxml2",
        ]
    else:
        # dependencies from schrodinger network
        windows_libs += WinLibFinder.get_schrodinger_libs()

    for lib in windows_libs:
        prefix_path.append(lib.rsplit('\\lib\\', 1)[0])

    ext_link_args += windows_libs

    if DEBUG:
        ext_comp_args += ['/Z7']
        ext_link_args += ['/DEBUG']

    libs += [
        "opengl32",
        "glu32",
    ]

if not (MAC or WIN):
    # mmpymolx
    if not options.no_mmlibs:
        libs += [
            "mkl_def",
            "mkl_rt",
            "json_linux-gcc-4.5.3_libmt",
        ]
        if os.getenv('OS_CPU', '') == 'Linux-x86':
            libs += [
                "mkl_ia32",
                "guide",
            ]
        else:
            libs += [
                "mkl_core",
                "mkl_intel_lp64",
                "mkl_vml_mc2",
                "mkl_vml_def",
                "mkl_sequential",
            ]

    libs += [
        "GL",
        "GLEW",
    ] + (not options.no_glut) * [
        "glut",
    ]

if options.use_vtkm != "no" and not CONDA_LOAD_DATA:
    for prefix in prefix_path:
        vtkm_inc_dir = os.path.join(prefix, "include",
                                    f"vtkm-{options.use_vtkm}")
        if os.path.exists(vtkm_inc_dir):
            break
    else:
        raise LookupError('VTK-m headers not found.'
                          f' PREFIX_PATH={":".join(prefix_path)}')
    def_macros += [
        ("_PYMOL_VTKM", None),
    ]
    inc_dirs += [
        vtkm_inc_dir,
        vtkm_inc_dir + "/vtkm/thirdparty/diy/vtkmdiy/include",
        vtkm_inc_dir + "/vtkm/thirdparty/lcl/vtkmlcl",
    ] + (options.use_vtkm == "1.5") * [
        vtkm_inc_dir + "/vtkm/thirdparty/diy",
        vtkm_inc_dir + "/vtkm/thirdparty/taotuple",
    ]
    libs += [
        f"vtkm_cont-{options.use_vtkm}",
        f"vtkm_filter-{options.use_vtkm}" if options.use_vtkm == "1.5" else
        f"vtkm_filter_contour-{options.use_vtkm}",
    ]

if options.vmd_plugins:
    libs += [
        "netcdf",
    ]

if options.openvr:
    libs += [
        "openvr_api",
    ]

if options.lookingglass:
    def_macros += [("_PYMOL_LOOKINGGLASS", None)]
    libs += [
        "HoloPlayCore",
    ]

if True:
    try:
        import numpy
        inc_dirs += [
            numpy.get_include(),
        ]
        def_macros += [
            ("_PYMOL_NUMPY", None),
        ]
    except ImportError:
        print("numpy not available")

if True:
    for prefix in prefix_path:
        for dirs, suffixes in [
            [
                inc_dirs,
                [("include", ), ("include", "freetype2"),
                 ("include", "libxml2"), ("include", "openvr")]
            ],
            [lib_dirs, [("lib64", ), ("lib", )]],
        ]:
            dirs.extend(
                filter(os.path.isdir,
                       [os.path.join(prefix, *s) for s in suffixes]))

if options.no_mmlibs:
    def_macros += [
        ("NO_MMLIBS", None),
    ]
else:
    libs += [
        "mmpymolx",
        "crypto",
        "imf",
        "ifcore",
        "ifport",
        "irc",
        "svml",
    ]
    if os.getenv('OS_CPU', '') != 'Linux-x86':
        libs += [
            "intlc",
            "iomp5",
        ]

if not options.no_licensing:
    def_macros += [
        ("_PYMOL_LICENSING", None),
    ]

    try:
        FLEXLM_DIR = WinLibFinder.find(r"flexlm11.15.0.0")
    except LookupError:
        FLEXLM_DIR = WinLibFinder.find(r"flexlm")

    if WIN:
        libs += [
            "comctl32",  # __imp_InitCommonControls
            "comdlg32",  # __imp_GetOpenFileNameA
            "dhcpcsvc",  # DhcpRequestParams
            "netapi32",  # Netbios
            "oleaut32",  # __imp_SysFreeString
            "ole32",  # __imp_CoUninitialize
            "shell32",  # __imp_IsUserAnAdmin
            "shlwapi",  # __imp_PathRemoveBackslashW
            "wbemuuid",  # CLSID_WbemLocator
            "userenv",  # GetProfilesDirectoryA
        ]

        def no_pic(s):
            if s.endswith('.o'):
                return s.replace('_pic.o', '_md.obj')
            s = s.replace('_pic', '')
            if not os.path.exists(os.path.join(FLEXLM_DIR, s + ".lib")):
                s = "lib" + s
            return s
    elif sys.platform == 'darwin':
        no_pic = lambda s: s.replace('_pic', '')
    else:
        no_pic = lambda s: s

    inc_dirs += [os.path.join(FLEXLM_DIR, 'include')]
    lib_dirs += [FLEXLM_DIR]
    libs += map(
        no_pic,
        ['lmgr_pic', 'noact_pic', 'lmgr_dongle_stub', 'crvs_pic', 'sb_pic'])

    if WIN:
        libs += map(no_pic, ['redir_std'])

    lm_new_filename = os.path.join(FLEXLM_DIR, no_pic('lm_new_pic.o'))

    ext_objects += [lm_new_filename]


def get_pymol_version():
    return re.findall(r'_PyMOL_VERSION "(.*)"',
                      open('layer0/Version.h').read())[0]


def get_sources(subdirs, suffixes=('.c', '.cpp')):
    return sorted([
        f for d in subdirs for s in suffixes for f in glob.glob(d + '/*' + s)
    ])


def get_packages(base, parent='', r=None):
    if r is None:
        r = []
    if parent:
        r.append(parent)
    dir = os.path.join(base, parent)
    for name in os.listdir(dir):
        init_py = os.path.join(base, parent, name, '__init__.py')
        if '.' not in name and os.path.exists(init_py):
            get_packages(base, os.path.join(parent, name), r)
    return r


package_dir = dict((x, os.path.join(base, x)) for base in ['modules']
                   for x in get_packages(base))

distribution = setup(
    cmdclass={
        'build_ext': build_ext_pymol,
        'build_py': build_py_pymol,
        'install': install_pymol,
    },
    name="pymol",
    version=get_pymol_version(),
    author="Schrodinger",
    url="http://pymol.org",
    contact="pymol-users@lists.sourceforge.net",
    description=(
        "PyMOL is a Python-enhanced molecular graphics tool. "
        "It excels at 3D visualization of proteins, small molecules, density, "
        "surfaces, and trajectories. It also includes molecular editing, "
        "ray tracing, and movies. Open Source PyMOL is free to everyone!"),
    package_dir=package_dir,
    packages=list(package_dir),
    ext_modules=[CMakeExtension('pymol._cmd')])


def get_anaconda_labels(user, package):
    '''Get the lists of labels for a package
    '''
    url = 'https://anaconda.org/{}/{}'.format(user, package)
    contents = urllib2.urlopen(url).read()
    return re.findall(r'conda install -c ({}\S*)'.format(user), contents)


def get_build_number(name, version):
    '''For meta.yaml: Check existing builds of this package and version
    and return the incremented build number.
    '''
    # this might get called multiple times, cache result because web
    # query is slow (repurpose sys.modules, it's a global dictionary)
    pyXY = 'py' + os.environ.get('CONDA_PY', '')

    if pyXY == 'py' and argparse is not None:
        parser = argparse.ArgumentParser()
        parser.add_argument('--python', default='')
        pyXY += parser.parse_known_args()[0].python.replace('.', '')[:2]

    cachekey = name + "-" + version + "-" + pyXY + "-BUILDNUM"
    build_number = sys.modules.get(cachekey)

    if build_number is None:
        import json

        url = 'https://api.anaconda.org/release/schrodinger/{}/{}'.format(
            name, version)
        try:
            contents = urllib2.urlopen(url).read()
        except Exception as e:
            print(e)
            return 0

        def build_number_gen():
            data = json.loads(contents)
            for dist in data.get('distributions', ()):
                a = dist['attrs']
                if (sys.platform.startswith(a['operatingsystem'])
                        and pyXY in a['build']):
                    yield a['build_number'] + 1
            yield 0

        build_number = max(build_number_gen())
        sys.modules[cachekey] = build_number

    return build_number


if CONDA_LOAD_DATA:
    '''
    This is a monkey-patched setup function from conda_build.jinja_context,
    implemented as:

        >>> def setup(**kw):
        ...     _setuptools_data.update(kw)

    '''
    setup(build_number=get_build_number("pymol", get_pymol_version()))
